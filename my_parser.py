from lexer import Lexer


# Base class for all Abstract Syntax Tree (AST) nodes
class ASTNode:
    def __str__(self):
        return self.__repr__()


# Node representing a number
class NumberNode(ASTNode):
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return f'NumberNode({self.value})'


# Node representing a boolean value
class BooleanNode(ASTNode):
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return f'BooleanNode({self.value})'


# Node representing an identifier (variable or function name)
class IdentifierNode(ASTNode):
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f'IdentifierNode({self.name})'


# Node representing a binary operation (e.g., addition, subtraction)
class BinaryOpNode(ASTNode):
    def __init__(self, left, op, right):
        self.left = left
        self.op = op
        self.right = right

    def __repr__(self):
        return f'BinaryOpNode({self.left}, {self.op}, {self.right})'


# Node representing a unary operation (e.g., logical NOT)
class UnaryOpNode(ASTNode):
    def __init__(self, op, operand):
        self.op = op
        self.operand = operand

    def __repr__(self):
        return f'UnaryOpNode({self.op}, {self.operand})'


# Node representing a lambda expression
class LambdaNode(ASTNode):
    def __init__(self, params, body):
        self.params = params
        self.body = body

    def __repr__(self):
        return f'LambdaNode(params={self.params}, body={self.body})'


# Node representing a function call
class FunctionCallNode(ASTNode):
    def __init__(self, func, args):
        self.func = func
        self.args = args

    def __repr__(self):
        return f'FunctionCallNode({self.func}, {self.args})'


# Node representing a function definition
class FunctionDefNode(ASTNode):
    def __init__(self, name, params, body):
        self.name = name
        self.params = params
        self.body = body

    def __repr__(self):
        return f'FunctionDefNode(name={self.name}, params={self.params}, body={self.body})'


# Node representing an if-else expression
class IfElseNode(ASTNode):
    def __init__(self, condition, if_body, else_body):
        self.condition = condition
        self.if_body = if_body
        self.else_body = else_body

    def __repr__(self):
        return f'IfElseNode(condition={self.condition}, if_body={self.if_body}, else_body={self.else_body})'


# Parser class to parse tokens into an AST
class Parser:
    def __init__(self, tokens):
        """
        Initialize the Parser with a list of tokens.

        :param tokens: List of tokens generated by the lexer.
        """
        self.tokens = tokens  # List of tokens to parse
        self.current_token_index = 0  # Index of the current token

    def parse(self):
        """
        Parse the tokens and return the corresponding AST.

        :return: The root node of the AST.
        """
        return self.statement()  # Start parsing from the statement

    def statement(self):
        """
        Parse a statement, which could be a function definition or an expression.

        :return: The corresponding AST node.
        """
        if self.current_token() and self.current_token()[0] == 'KEYWORD' and self.current_token()[1] == 'def':
            return self.function_definition()  # Parse a function definition
        return self.expression()  # Parse an expression

    def function_definition(self):
        """
        Parse a function definition.

        :return: A FunctionDefNode representing the function definition.
        """
        self.eat('def')  # Consume the 'def' keyword
        name = self.current_token()[1]  # Get the function name
        self.eat('ID')  # Consume the identifier token
        self.eat('LPAREN')  # Consume the left parenthesis
        params = []  # List to hold parameter names
        if self.current_token() and self.current_token()[0] == 'ID':
            params.append(self.current_token()[1])  # Add the first parameter
            self.eat('ID')  # Consume the identifier token
            while self.current_token() and self.current_token()[0] == 'DELIM':
                self.eat('DELIM')  # Consume the comma
                if self.current_token() and self.current_token()[0] == 'ID':
                    params.append(self.current_token()[1])  # Add the next parameter
                    self.eat('ID')  # Consume the identifier token
                else:
                    raise Exception(f'Unexpected token: {self.current_token()}')
        self.eat('RPAREN')  # Consume the right parenthesis
        self.eat('COLON')  # Consume the colon
        body = self.expression()  # Parse the function body
        return FunctionDefNode(name=name, params=params, body=body)

    def expression(self):
        """
        Parse an expression.

        :return: The corresponding AST node.
        """
        node = self.term()  # Parse the first term
        while self.current_token() and self.current_token()[0] in ('OP', 'COMPARE', 'LOGICAL'):
            token = self.current_token()  # Get the current token
            self.eat(token[0])  # Consume the operator
            node = BinaryOpNode(left=node, op=token[1], right=self.term())  # Create a BinaryOpNode
        return node

    def term(self):
        """
        Parse a term.

        :return: The corresponding AST node.
        """
        node = self.factor()  # Parse the first factor
        while self.current_token() and self.current_token()[0] == 'OP' and self.current_token()[1] in ('*', '/', '%'):
            token = self.current_token()  # Get the current token
            self.eat('OP')  # Consume the operator
            node = BinaryOpNode(left=node, op=token[1], right=self.factor())  # Create a BinaryOpNode
        return node

    def factor(self):
        token = self.current_token()

        # Handle negative numbers
        if token[0] == 'OP' and token[1] == '-':
            self.eat('OP')
            num = self.current_token()
            if num[0] == 'NUMBER':
                self.eat('NUMBER')
                return NumberNode(value=-num[1])
            else:
                raise Exception(f'Unexpected token: {num}, expected a number after "-"')

        if token[0] == 'NUMBER':
            self.eat('NUMBER')
            return NumberNode(value=token[1])
        elif token[0] == 'BOOLEAN':
            self.eat('BOOLEAN')
            return BooleanNode(value=token[1])
        elif token[0] == 'ID':
            self.eat('ID')
            if self.current_token() and self.current_token()[0] == 'LPAREN':
                return self.function_call(IdentifierNode(name=token[1]))
            return IdentifierNode(name=token[1])
        elif token[0] == 'LPAREN':
            self.eat('LPAREN')
            node = self.expression()
            self.eat('RPAREN')
            if self.current_token() and self.current_token()[0] == 'LPAREN':
                return self.function_call(node)
            return node
        elif token[0] == 'NOT':
            self.eat('NOT')
            return UnaryOpNode(op='!', operand=self.factor())
        elif token[0] == 'KEYWORD' and token[1] == 'lambda':
            return self.lambda_expression()
        elif token[0] == 'KEYWORD' and token[1] == 'if':
            return self.if_else_expression()
        raise Exception(f'Unexpected token: {token}')

    def lambda_expression(self):
        """
        Parse a lambda expression.

        :return: A LambdaNode representing the lambda expression.
        """
        self.eat('lambda')  # Consume the 'lambda' keyword
        params = []  # List to hold parameter names
        if self.current_token() and self.current_token()[0] == 'ID':
            params.append(self.current_token()[1])  # Add the first parameter
            self.eat('ID')  # Consume the identifier token
            while self.current_token() and self.current_token()[0] == 'DELIM':
                self.eat('DELIM')  # Consume the comma
                if self.current_token() and self.current_token()[0] == 'ID':
                    params.append(self.current_token()[1])  # Add the next parameter
                    self.eat('ID')  # Consume the identifier token
                else:
                    raise Exception(f'Unexpected token: {self.current_token()}')
        self.eat('COLON')  # Consume the colon
        body = self.expression()  # Parse the lambda body
        return LambdaNode(params=params, body=body)

    def if_else_expression(self):
        """
        Parse an if-else expression.

        :return: An IfElseNode representing the if-else expression.
        """
        self.eat('if')  # Consume the 'if' keyword
        condition = self.expression()  # Parse the condition
        self.eat('COLON')  # Consume the colon
        if_body = self.expression()  # Parse the 'if' body
        if self.current_token() and self.current_token()[0] == 'KEYWORD' and self.current_token()[1] == 'else':
            self.eat('else')  # Consume the 'else' keyword
            self.eat('COLON')  # Consume the colon
            else_body = self.expression()  # Parse the 'else' body
        else:
            raise Exception(f'Expected else but got {self.current_token()}')
        return IfElseNode(condition=condition, if_body=if_body, else_body=else_body)

    def function_call(self, func):
        """
        Parse a function call.

        :param func: The function being called.
        :return: A FunctionCallNode representing the function call.
        """
        self.eat('LPAREN')  # Consume the left parenthesis
        args = []  # List to hold arguments
        if self.current_token() and self.current_token()[0] != 'RPAREN':
            args.append(self.expression())  # Add the first argument
            while self.current_token() and self.current_token()[0] == 'DELIM':
                self.eat('DELIM')  # Consume the comma
                args.append(self.expression())  # Add the next argument
        self.eat('RPAREN')  # Consume the right parenthesis
        return FunctionCallNode(func=func, args=args)

    def current_token(self):
        """
        Get the current token.

        :return: The current token or None if there are no more tokens.
        """
        return self.tokens[self.current_token_index] if self.current_token_index < len(self.tokens) else None

    def eat(self, token_type):
        """
        Consume the current token if it matches the expected type.

        :param token_type: The expected type of the current token.
        :raises Exception: If the current token does not match the expected type.
        """
        if self.current_token() and (self.current_token()[0] == token_type or self.current_token()[1] == token_type):
            self.current_token_index += 1  # Move to the next token
        else:
            expected = token_type  # What we expected
            found = self.current_token()  # What we found
            raise Exception(f'Unexpected token: {found}, expected: {expected} at position {self.current_token_index}')
